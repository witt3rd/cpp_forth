mem 1 + 1 .
mem 28 + 1 .

0 while dup 30 < do

  0 while dup 30 < do
    dup mem + , if
      mem 30 + 42 .
    else
      mem 30 + 32 .
    end
    1 mem 30 + 1 1 syscall3

    1 +
  end
  drop

  mem 30 + 10 .
  1 mem 30 + 1 1 syscall3

  // pattern =
  mem     , 1 shl // mem[0] << 1
  mem 1 + ,       // mem[1]
  bor             // mem[0] | mem[1]

  1 while dup 28 < do           // index
     swap 1 shl 7 band          // ((pattern << 1) & 7)
     over mem + 1 + , bor       // | (mem[index + 1]) = new_pattern
     2dup 110 swap shr 1 band   // ((110 >> new_pattern) & 1)
     swap mem + swap .
     swap

     1 +
  end
  drop
  drop

  1 +
end
drop
